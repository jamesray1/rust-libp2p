// This file is generated by rust-protobuf 2.0.2. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct RPC {
    // message fields
    subscriptions: ::protobuf::RepeatedField<RPC_SubOpts>,
    publish: ::protobuf::RepeatedField<Message>,
    control: ::protobuf::SingularPtrField<ControlMessage>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RPC {
    pub fn new() -> RPC {
        ::std::default::Default::default()
    }

    // repeated .pubsub.pb.RPC.SubOpts subscriptions = 1;

    pub fn clear_subscriptions(&mut self) {
        self.subscriptions.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscriptions(&mut self, v: ::protobuf::RepeatedField<RPC_SubOpts>) {
        self.subscriptions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subscriptions(&mut self) -> &mut ::protobuf::RepeatedField<RPC_SubOpts> {
        &mut self.subscriptions
    }

    // Take field
    pub fn take_subscriptions(&mut self) -> ::protobuf::RepeatedField<RPC_SubOpts> {
        ::std::mem::replace(&mut self.subscriptions, ::protobuf::RepeatedField::new())
    }

    pub fn get_subscriptions(&self) -> &[RPC_SubOpts] {
        &self.subscriptions
    }

    // repeated .pubsub.pb.Message publish = 2;

    pub fn clear_publish(&mut self) {
        self.publish.clear();
    }

    // Param is passed by value, moved
    pub fn set_publish(&mut self, v: ::protobuf::RepeatedField<Message>) {
        self.publish = v;
    }

    // Mutable pointer to the field.
    pub fn mut_publish(&mut self) -> &mut ::protobuf::RepeatedField<Message> {
        &mut self.publish
    }

    // Take field
    pub fn take_publish(&mut self) -> ::protobuf::RepeatedField<Message> {
        ::std::mem::replace(&mut self.publish, ::protobuf::RepeatedField::new())
    }

    pub fn get_publish(&self) -> &[Message] {
        &self.publish
    }

    // optional .pubsub.pb.ControlMessage control = 3;

    pub fn clear_control(&mut self) {
        self.control.clear();
    }

    pub fn has_control(&self) -> bool {
        self.control.is_some()
    }

    // Param is passed by value, moved
    pub fn set_control(&mut self, v: ControlMessage) {
        self.control = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_control(&mut self) -> &mut ControlMessage {
        if self.control.is_none() {
            self.control.set_default();
        }
        self.control.as_mut().unwrap()
    }

    // Take field
    pub fn take_control(&mut self) -> ControlMessage {
        self.control.take().unwrap_or_else(|| ControlMessage::new())
    }

    pub fn get_control(&self) -> &ControlMessage {
        self.control.as_ref().unwrap_or_else(|| ControlMessage::default_instance())
    }
}

impl ::protobuf::Message for RPC {
    fn is_initialized(&self) -> bool {
        for v in &self.subscriptions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.publish {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.control {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subscriptions)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.publish)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.control)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.subscriptions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.publish {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.control.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.subscriptions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.publish {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.control.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RPC {
        RPC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RPC_SubOpts>>(
                    "subscriptions",
                    |m: &RPC| { &m.subscriptions },
                    |m: &mut RPC| { &mut m.subscriptions },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Message>>(
                    "publish",
                    |m: &RPC| { &m.publish },
                    |m: &mut RPC| { &mut m.publish },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ControlMessage>>(
                    "control",
                    |m: &RPC| { &m.control },
                    |m: &mut RPC| { &mut m.control },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RPC>(
                    "RPC",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RPC {
        static mut instance: ::protobuf::lazy::Lazy<RPC> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RPC,
        };
        unsafe {
            instance.get(RPC::new)
        }
    }
}

impl ::protobuf::Clear for RPC {
    fn clear(&mut self) {
        self.clear_subscriptions();
        self.clear_publish();
        self.clear_control();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RPC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RPC {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RPC_SubOpts {
    // message fields
    subscribe: ::std::option::Option<bool>,
    topic_hash: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RPC_SubOpts {
    pub fn new() -> RPC_SubOpts {
        ::std::default::Default::default()
    }

    // optional bool subscribe = 1;

    pub fn clear_subscribe(&mut self) {
        self.subscribe = ::std::option::Option::None;
    }

    pub fn has_subscribe(&self) -> bool {
        self.subscribe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscribe(&mut self, v: bool) {
        self.subscribe = ::std::option::Option::Some(v);
    }

    pub fn get_subscribe(&self) -> bool {
        self.subscribe.unwrap_or(false)
    }

    // optional string topic_hash = 2;

    pub fn clear_topic_hash(&mut self) {
        self.topic_hash.clear();
    }

    pub fn has_topic_hash(&self) -> bool {
        self.topic_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topic_hash(&mut self, v: ::std::string::String) {
        self.topic_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic_hash(&mut self) -> &mut ::std::string::String {
        if self.topic_hash.is_none() {
            self.topic_hash.set_default();
        }
        self.topic_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_topic_hash(&mut self) -> ::std::string::String {
        self.topic_hash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_topic_hash(&self) -> &str {
        match self.topic_hash.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RPC_SubOpts {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.subscribe = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.topic_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.subscribe {
            my_size += 2;
        }
        if let Some(ref v) = self.topic_hash.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.subscribe {
            os.write_bool(1, v)?;
        }
        if let Some(ref v) = self.topic_hash.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RPC_SubOpts {
        RPC_SubOpts::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "subscribe",
                    |m: &RPC_SubOpts| { &m.subscribe },
                    |m: &mut RPC_SubOpts| { &mut m.subscribe },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "topic_hash",
                    |m: &RPC_SubOpts| { &m.topic_hash },
                    |m: &mut RPC_SubOpts| { &mut m.topic_hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RPC_SubOpts>(
                    "RPC_SubOpts",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RPC_SubOpts {
        static mut instance: ::protobuf::lazy::Lazy<RPC_SubOpts> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RPC_SubOpts,
        };
        unsafe {
            instance.get(RPC_SubOpts::new)
        }
    }
}

impl ::protobuf::Clear for RPC_SubOpts {
    fn clear(&mut self) {
        self.clear_subscribe();
        self.clear_topic_hash();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RPC_SubOpts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RPC_SubOpts {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Message {
    // message fields
    from: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    seqno: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    topic_hashes: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Message {
    pub fn new() -> Message {
        ::std::default::Default::default()
    }

    // optional bytes from = 1;

    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    pub fn has_from(&self) -> bool {
        self.from.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::std::vec::Vec<u8>) {
        self.from = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.from.is_none() {
            self.from.set_default();
        }
        self.from.as_mut().unwrap()
    }

    // Take field
    pub fn take_from(&mut self) -> ::std::vec::Vec<u8> {
        self.from.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_from(&self) -> &[u8] {
        match self.from.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bytes data = 2;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bytes seqno = 3;

    pub fn clear_seqno(&mut self) {
        self.seqno.clear();
    }

    pub fn has_seqno(&self) -> bool {
        self.seqno.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seqno(&mut self, v: ::std::vec::Vec<u8>) {
        self.seqno = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seqno(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.seqno.is_none() {
            self.seqno.set_default();
        }
        self.seqno.as_mut().unwrap()
    }

    // Take field
    pub fn take_seqno(&mut self) -> ::std::vec::Vec<u8> {
        self.seqno.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_seqno(&self) -> &[u8] {
        match self.seqno.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // repeated string topic_hashes = 4;

    pub fn clear_topic_hashes(&mut self) {
        self.topic_hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_topic_hashes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.topic_hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_topic_hashes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.topic_hashes
    }

    // Take field
    pub fn take_topic_hashes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.topic_hashes, ::protobuf::RepeatedField::new())
    }

    pub fn get_topic_hashes(&self) -> &[::std::string::String] {
        &self.topic_hashes
    }
}

impl ::protobuf::Message for Message {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.from)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.seqno)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.topic_hashes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.from.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.seqno.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        for value in &self.topic_hashes {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.from.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.seqno.as_ref() {
            os.write_bytes(3, &v)?;
        }
        for v in &self.topic_hashes {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Message {
        Message::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "from",
                    |m: &Message| { &m.from },
                    |m: &mut Message| { &mut m.from },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &Message| { &m.data },
                    |m: &mut Message| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "seqno",
                    |m: &Message| { &m.seqno },
                    |m: &mut Message| { &mut m.seqno },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "topic_hashes",
                    |m: &Message| { &m.topic_hashes },
                    |m: &mut Message| { &mut m.topic_hashes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Message>(
                    "Message",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Message {
        static mut instance: ::protobuf::lazy::Lazy<Message> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Message,
        };
        unsafe {
            instance.get(Message::new)
        }
    }
}

impl ::protobuf::Clear for Message {
    fn clear(&mut self) {
        self.clear_from();
        self.clear_data();
        self.clear_seqno();
        self.clear_topic_hashes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Message {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ControlMessage {
    // message fields
    ihave: ::protobuf::RepeatedField<ControlIHave>,
    iwant: ::protobuf::RepeatedField<ControlIWant>,
    graft: ::protobuf::RepeatedField<ControlGraft>,
    prune: ::protobuf::RepeatedField<ControlPrune>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ControlMessage {
    pub fn new() -> ControlMessage {
        ::std::default::Default::default()
    }

    // repeated .pubsub.pb.ControlIHave ihave = 1;

    pub fn clear_ihave(&mut self) {
        self.ihave.clear();
    }

    // Param is passed by value, moved
    pub fn set_ihave(&mut self, v: ::protobuf::RepeatedField<ControlIHave>) {
        self.ihave = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ihave(&mut self) -> &mut ::protobuf::RepeatedField<ControlIHave> {
        &mut self.ihave
    }

    // Take field
    pub fn take_ihave(&mut self) -> ::protobuf::RepeatedField<ControlIHave> {
        ::std::mem::replace(&mut self.ihave, ::protobuf::RepeatedField::new())
    }

    pub fn get_ihave(&self) -> &[ControlIHave] {
        &self.ihave
    }

    // repeated .pubsub.pb.ControlIWant iwant = 2;

    pub fn clear_iwant(&mut self) {
        self.iwant.clear();
    }

    // Param is passed by value, moved
    pub fn set_iwant(&mut self, v: ::protobuf::RepeatedField<ControlIWant>) {
        self.iwant = v;
    }

    // Mutable pointer to the field.
    pub fn mut_iwant(&mut self) -> &mut ::protobuf::RepeatedField<ControlIWant> {
        &mut self.iwant
    }

    // Take field
    pub fn take_iwant(&mut self) -> ::protobuf::RepeatedField<ControlIWant> {
        ::std::mem::replace(&mut self.iwant, ::protobuf::RepeatedField::new())
    }

    pub fn get_iwant(&self) -> &[ControlIWant] {
        &self.iwant
    }

    // repeated .pubsub.pb.ControlGraft graft = 3;

    pub fn clear_graft(&mut self) {
        self.graft.clear();
    }

    // Param is passed by value, moved
    pub fn set_graft(&mut self, v: ::protobuf::RepeatedField<ControlGraft>) {
        self.graft = v;
    }

    // Mutable pointer to the field.
    pub fn mut_graft(&mut self) -> &mut ::protobuf::RepeatedField<ControlGraft> {
        &mut self.graft
    }

    // Take field
    pub fn take_graft(&mut self) -> ::protobuf::RepeatedField<ControlGraft> {
        ::std::mem::replace(&mut self.graft, ::protobuf::RepeatedField::new())
    }

    pub fn get_graft(&self) -> &[ControlGraft] {
        &self.graft
    }

    // repeated .pubsub.pb.ControlPrune prune = 4;

    pub fn clear_prune(&mut self) {
        self.prune.clear();
    }

    // Param is passed by value, moved
    pub fn set_prune(&mut self, v: ::protobuf::RepeatedField<ControlPrune>) {
        self.prune = v;
    }

    // Mutable pointer to the field.
    pub fn mut_prune(&mut self) -> &mut ::protobuf::RepeatedField<ControlPrune> {
        &mut self.prune
    }

    // Take field
    pub fn take_prune(&mut self) -> ::protobuf::RepeatedField<ControlPrune> {
        ::std::mem::replace(&mut self.prune, ::protobuf::RepeatedField::new())
    }

    pub fn get_prune(&self) -> &[ControlPrune] {
        &self.prune
    }
}

impl ::protobuf::Message for ControlMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.ihave {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.iwant {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.graft {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.prune {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ihave)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.iwant)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.graft)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.prune)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ihave {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.iwant {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.graft {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.prune {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ihave {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.iwant {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.graft {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.prune {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ControlMessage {
        ControlMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ControlIHave>>(
                    "ihave",
                    |m: &ControlMessage| { &m.ihave },
                    |m: &mut ControlMessage| { &mut m.ihave },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ControlIWant>>(
                    "iwant",
                    |m: &ControlMessage| { &m.iwant },
                    |m: &mut ControlMessage| { &mut m.iwant },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ControlGraft>>(
                    "graft",
                    |m: &ControlMessage| { &m.graft },
                    |m: &mut ControlMessage| { &mut m.graft },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ControlPrune>>(
                    "prune",
                    |m: &ControlMessage| { &m.prune },
                    |m: &mut ControlMessage| { &mut m.prune },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ControlMessage>(
                    "ControlMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ControlMessage {
        static mut instance: ::protobuf::lazy::Lazy<ControlMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ControlMessage,
        };
        unsafe {
            instance.get(ControlMessage::new)
        }
    }
}

impl ::protobuf::Clear for ControlMessage {
    fn clear(&mut self) {
        self.clear_ihave();
        self.clear_iwant();
        self.clear_graft();
        self.clear_prune();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ControlMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControlMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ControlIHave {
    // message fields
    topic_hash: ::protobuf::SingularField<::std::string::String>,
    message_hashes: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ControlIHave {
    pub fn new() -> ControlIHave {
        ::std::default::Default::default()
    }

    // optional string topic_hash = 1;

    pub fn clear_topic_hash(&mut self) {
        self.topic_hash.clear();
    }

    pub fn has_topic_hash(&self) -> bool {
        self.topic_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topic_hash(&mut self, v: ::std::string::String) {
        self.topic_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic_hash(&mut self) -> &mut ::std::string::String {
        if self.topic_hash.is_none() {
            self.topic_hash.set_default();
        }
        self.topic_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_topic_hash(&mut self) -> ::std::string::String {
        self.topic_hash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_topic_hash(&self) -> &str {
        match self.topic_hash.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string message_hashes = 2;

    pub fn clear_message_hashes(&mut self) {
        self.message_hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_hashes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.message_hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_message_hashes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.message_hashes
    }

    // Take field
    pub fn take_message_hashes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.message_hashes, ::protobuf::RepeatedField::new())
    }

    pub fn get_message_hashes(&self) -> &[::std::string::String] {
        &self.message_hashes
    }
}

impl ::protobuf::Message for ControlIHave {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.topic_hash)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.message_hashes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.topic_hash.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.message_hashes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.topic_hash.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.message_hashes {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ControlIHave {
        ControlIHave::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "topic_hash",
                    |m: &ControlIHave| { &m.topic_hash },
                    |m: &mut ControlIHave| { &mut m.topic_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message_hashes",
                    |m: &ControlIHave| { &m.message_hashes },
                    |m: &mut ControlIHave| { &mut m.message_hashes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ControlIHave>(
                    "ControlIHave",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ControlIHave {
        static mut instance: ::protobuf::lazy::Lazy<ControlIHave> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ControlIHave,
        };
        unsafe {
            instance.get(ControlIHave::new)
        }
    }
}

impl ::protobuf::Clear for ControlIHave {
    fn clear(&mut self) {
        self.clear_topic_hash();
        self.clear_message_hashes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ControlIHave {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControlIHave {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ControlIWant {
    // message fields
    message_hashes: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ControlIWant {
    pub fn new() -> ControlIWant {
        ::std::default::Default::default()
    }

    // repeated string message_hashes = 1;

    pub fn clear_message_hashes(&mut self) {
        self.message_hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_hashes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.message_hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_message_hashes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.message_hashes
    }

    // Take field
    pub fn take_message_hashes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.message_hashes, ::protobuf::RepeatedField::new())
    }

    pub fn get_message_hashes(&self) -> &[::std::string::String] {
        &self.message_hashes
    }
}

impl ::protobuf::Message for ControlIWant {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.message_hashes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.message_hashes {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.message_hashes {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ControlIWant {
        ControlIWant::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message_hashes",
                    |m: &ControlIWant| { &m.message_hashes },
                    |m: &mut ControlIWant| { &mut m.message_hashes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ControlIWant>(
                    "ControlIWant",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ControlIWant {
        static mut instance: ::protobuf::lazy::Lazy<ControlIWant> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ControlIWant,
        };
        unsafe {
            instance.get(ControlIWant::new)
        }
    }
}

impl ::protobuf::Clear for ControlIWant {
    fn clear(&mut self) {
        self.clear_message_hashes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ControlIWant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControlIWant {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ControlGraft {
    // message fields
    topic_hash: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ControlGraft {
    pub fn new() -> ControlGraft {
        ::std::default::Default::default()
    }

    // optional string topic_hash = 1;

    pub fn clear_topic_hash(&mut self) {
        self.topic_hash.clear();
    }

    pub fn has_topic_hash(&self) -> bool {
        self.topic_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topic_hash(&mut self, v: ::std::string::String) {
        self.topic_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic_hash(&mut self) -> &mut ::std::string::String {
        if self.topic_hash.is_none() {
            self.topic_hash.set_default();
        }
        self.topic_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_topic_hash(&mut self) -> ::std::string::String {
        self.topic_hash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_topic_hash(&self) -> &str {
        match self.topic_hash.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ControlGraft {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.topic_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.topic_hash.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.topic_hash.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ControlGraft {
        ControlGraft::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "topic_hash",
                    |m: &ControlGraft| { &m.topic_hash },
                    |m: &mut ControlGraft| { &mut m.topic_hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ControlGraft>(
                    "ControlGraft",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ControlGraft {
        static mut instance: ::protobuf::lazy::Lazy<ControlGraft> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ControlGraft,
        };
        unsafe {
            instance.get(ControlGraft::new)
        }
    }
}

impl ::protobuf::Clear for ControlGraft {
    fn clear(&mut self) {
        self.clear_topic_hash();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ControlGraft {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControlGraft {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ControlPrune {
    // message fields
    topic_hash: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ControlPrune {
    pub fn new() -> ControlPrune {
        ::std::default::Default::default()
    }

    // optional string topic_hash = 1;

    pub fn clear_topic_hash(&mut self) {
        self.topic_hash.clear();
    }

    pub fn has_topic_hash(&self) -> bool {
        self.topic_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topic_hash(&mut self, v: ::std::string::String) {
        self.topic_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic_hash(&mut self) -> &mut ::std::string::String {
        if self.topic_hash.is_none() {
            self.topic_hash.set_default();
        }
        self.topic_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_topic_hash(&mut self) -> ::std::string::String {
        self.topic_hash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_topic_hash(&self) -> &str {
        match self.topic_hash.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ControlPrune {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.topic_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.topic_hash.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.topic_hash.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ControlPrune {
        ControlPrune::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "topic_hash",
                    |m: &ControlPrune| { &m.topic_hash },
                    |m: &mut ControlPrune| { &mut m.topic_hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ControlPrune>(
                    "ControlPrune",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ControlPrune {
        static mut instance: ::protobuf::lazy::Lazy<ControlPrune> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ControlPrune,
        };
        unsafe {
            instance.get(ControlPrune::new)
        }
    }
}

impl ::protobuf::Clear for ControlPrune {
    fn clear(&mut self) {
        self.clear_topic_hash();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ControlPrune {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControlPrune {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TopicDescriptor {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl TopicDescriptor {
    pub fn new() -> TopicDescriptor {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for TopicDescriptor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TopicDescriptor {
        TopicDescriptor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &TopicDescriptor| { &m.name },
                    |m: &mut TopicDescriptor| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TopicDescriptor>(
                    "TopicDescriptor",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TopicDescriptor {
        static mut instance: ::protobuf::lazy::Lazy<TopicDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TopicDescriptor,
        };
        unsafe {
            instance.get(TopicDescriptor::new)
        }
    }
}

impl ::protobuf::Clear for TopicDescriptor {
    fn clear(&mut self) {
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TopicDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TopicDescriptor {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\trpc.proto\x12\tpubsub.pb\"\xee\x01\n\x03RPC\x12<\n\rsubscriptions\
    \x18\x01\x20\x03(\x0b2\x16.pubsub.pb.RPC.SubOptsR\rsubscriptions\x12,\n\
    \x07publish\x18\x02\x20\x03(\x0b2\x12.pubsub.pb.MessageR\x07publish\x123\
    \n\x07control\x18\x03\x20\x01(\x0b2\x19.pubsub.pb.ControlMessageR\x07con\
    trol\x1aF\n\x07SubOpts\x12\x1c\n\tsubscribe\x18\x01\x20\x01(\x08R\tsubsc\
    ribe\x12\x1d\n\ntopic_hash\x18\x02\x20\x01(\tR\ttopicHash\"j\n\x07Messag\
    e\x12\x12\n\x04from\x18\x01\x20\x01(\x0cR\x04from\x12\x12\n\x04data\x18\
    \x02\x20\x01(\x0cR\x04data\x12\x14\n\x05seqno\x18\x03\x20\x01(\x0cR\x05s\
    eqno\x12!\n\x0ctopic_hashes\x18\x04\x20\x03(\tR\x0btopicHashes\"\xcc\x01\
    \n\x0eControlMessage\x12-\n\x05ihave\x18\x01\x20\x03(\x0b2\x17.pubsub.pb\
    .ControlIHaveR\x05ihave\x12-\n\x05iwant\x18\x02\x20\x03(\x0b2\x17.pubsub\
    .pb.ControlIWantR\x05iwant\x12-\n\x05graft\x18\x03\x20\x03(\x0b2\x17.pub\
    sub.pb.ControlGraftR\x05graft\x12-\n\x05prune\x18\x04\x20\x03(\x0b2\x17.\
    pubsub.pb.ControlPruneR\x05prune\"T\n\x0cControlIHave\x12\x1d\n\ntopic_h\
    ash\x18\x01\x20\x01(\tR\ttopicHash\x12%\n\x0emessage_hashes\x18\x02\x20\
    \x03(\tR\rmessageHashes\"5\n\x0cControlIWant\x12%\n\x0emessage_hashes\
    \x18\x01\x20\x03(\tR\rmessageHashes\"-\n\x0cControlGraft\x12\x1d\n\ntopi\
    c_hash\x18\x01\x20\x01(\tR\ttopicHash\"-\n\x0cControlPrune\x12\x1d\n\nto\
    pic_hash\x18\x01\x20\x01(\tR\ttopicHash\"%\n\x0fTopicDescriptor\x12\x12\
    \n\x04name\x18\x01\x20\x01(\tR\x04nameJ\xc0\x14\n\x06\x12\x04\x03\0c\x01\
    \n\x87\x01\n\x01\x0c\x12\x03\x03\0\x122}\x20From\x20https://github.com/l\
    ibp2p/go-libp2p-pubsub/blob/master/pb/rpc.proto,\n\x20should\x20be\x20th\
    e\x20same\x20unless\x20that\x20has\x20been\x20changed.\n\n\xa6\x01\n\x01\
    \x02\x12\x03\x0c\x08\x112,\x20import\x20\"google/protobuf/descriptor.pro\
    to\";\n2n\x20extend\x20google.protobuf.EnumValueOptions\x20{\n\x20\topti\
    onal\x20string\x20type=\x2051234;\n\x20\toptional\x20string\x20code=\x20\
    51235;\n\x20\x20\x20}\n\n\n\n\x02\x04\0\x12\x04\x0e\0\x18\x01\n\n\n\x03\
    \x04\0\x01\x12\x03\x0e\x08\x0b\n\x0b\n\x04\x04\0\x02\0\x12\x03\x0f\x08+\
    \n\x0c\n\x05\x04\0\x02\0\x04\x12\x03\x0f\x08\x10\n\x0c\n\x05\x04\0\x02\0\
    \x06\x12\x03\x0f\x11\x18\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x0f\x19&\n\
    \x0c\n\x05\x04\0\x02\0\x03\x12\x03\x0f)*\n\x0b\n\x04\x04\0\x02\x01\x12\
    \x03\x10\x08%\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03\x10\x08\x10\n\x0c\n\
    \x05\x04\0\x02\x01\x06\x12\x03\x10\x11\x18\n\x0c\n\x05\x04\0\x02\x01\x01\
    \x12\x03\x10\x19\x20\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x10#$\n\x0c\n\
    \x04\x04\0\x03\0\x12\x04\x12\x08\x15\t\n\x0c\n\x05\x04\0\x03\0\x01\x12\
    \x03\x12\x10\x17\n(\n\x06\x04\0\x03\0\x02\0\x12\x03\x13\x10,\"\x19\x20su\
    bscribe\x20or\x20unsubcribe\n\n\x0e\n\x07\x04\0\x03\0\x02\0\x04\x12\x03\
    \x13\x10\x18\n\x0e\n\x07\x04\0\x03\0\x02\0\x05\x12\x03\x13\x19\x1d\n\x0e\
    \n\x07\x04\0\x03\0\x02\0\x01\x12\x03\x13\x1e'\n\x0e\n\x07\x04\0\x03\0\
    \x02\0\x03\x12\x03\x13*+\n\r\n\x06\x04\0\x03\0\x02\x01\x12\x03\x14\x10/\
    \n\x0e\n\x07\x04\0\x03\0\x02\x01\x04\x12\x03\x14\x10\x18\n\x0e\n\x07\x04\
    \0\x03\0\x02\x01\x05\x12\x03\x14\x19\x1f\n\x0e\n\x07\x04\0\x03\0\x02\x01\
    \x01\x12\x03\x14\x20*\n\x0e\n\x07\x04\0\x03\0\x02\x01\x03\x12\x03\x14-.\
    \n\x0b\n\x04\x04\0\x02\x02\x12\x03\x17\x08,\n\x0c\n\x05\x04\0\x02\x02\
    \x04\x12\x03\x17\x08\x10\n\x0c\n\x05\x04\0\x02\x02\x06\x12\x03\x17\x11\
    \x1f\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x17\x20'\n\x0c\n\x05\x04\0\
    \x02\x02\x03\x12\x03\x17*+\n\n\n\x02\x04\x01\x12\x04\x1a\0\"\x01\n\n\n\
    \x03\x04\x01\x01\x12\x03\x1a\x08\x0f\n\x0b\n\x04\x04\x01\x02\0\x12\x03\
    \x1b\x08\x20\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03\x1b\x08\x10\n\x0c\n\
    \x05\x04\x01\x02\0\x05\x12\x03\x1b\x11\x16\n\x0c\n\x05\x04\x01\x02\0\x01\
    \x12\x03\x1b\x17\x1b\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x1b\x1e\x1f\n\
    \x0b\n\x04\x04\x01\x02\x01\x12\x03\x1c\x08\x20\n\x0c\n\x05\x04\x01\x02\
    \x01\x04\x12\x03\x1c\x08\x10\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\x1c\
    \x11\x16\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x1c\x17\x1b\n\x0c\n\x05\
    \x04\x01\x02\x01\x03\x12\x03\x1c\x1e\x1f\n\x0b\n\x04\x04\x01\x02\x02\x12\
    \x03\x1d\x08!\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03\x1d\x08\x10\n\x0c\
    \n\x05\x04\x01\x02\x02\x05\x12\x03\x1d\x11\x16\n\x0c\n\x05\x04\x01\x02\
    \x02\x01\x12\x03\x1d\x17\x1c\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03\x1d\
    \x1f\x20\nP\n\x04\x04\x01\x02\x03\x12\x03\x1e\x08)\"C\x20TODO:\x20use\n\
    \x20optional\x20bytes\x20signature\x20=\x205;\n\x20optional\x20bytes\x20\
    key\x20=\x206;\n\n\x0c\n\x05\x04\x01\x02\x03\x04\x12\x03\x1e\x08\x10\n\
    \x0c\n\x05\x04\x01\x02\x03\x05\x12\x03\x1e\x11\x17\n\x0c\n\x05\x04\x01\
    \x02\x03\x01\x12\x03\x1e\x18$\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03\
    \x1e'(\n\n\n\x02\x04\x02\x12\x04$\0)\x01\n\n\n\x03\x04\x02\x01\x12\x03$\
    \x08\x16\n\x0b\n\x04\x04\x02\x02\0\x12\x03%\x08(\n\x0c\n\x05\x04\x02\x02\
    \0\x04\x12\x03%\x08\x10\n\x0c\n\x05\x04\x02\x02\0\x06\x12\x03%\x11\x1d\n\
    \x0c\n\x05\x04\x02\x02\0\x01\x12\x03%\x1e#\n\x0c\n\x05\x04\x02\x02\0\x03\
    \x12\x03%&'\n\x0b\n\x04\x04\x02\x02\x01\x12\x03&\x08(\n\x0c\n\x05\x04\
    \x02\x02\x01\x04\x12\x03&\x08\x10\n\x0c\n\x05\x04\x02\x02\x01\x06\x12\
    \x03&\x11\x1d\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03&\x1e#\n\x0c\n\x05\
    \x04\x02\x02\x01\x03\x12\x03&&'\n\x0b\n\x04\x04\x02\x02\x02\x12\x03'\x08\
    (\n\x0c\n\x05\x04\x02\x02\x02\x04\x12\x03'\x08\x10\n\x0c\n\x05\x04\x02\
    \x02\x02\x06\x12\x03'\x11\x1d\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03'\
    \x1e#\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03'&'\n\x0b\n\x04\x04\x02\x02\
    \x03\x12\x03(\x08(\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\x03(\x08\x10\n\
    \x0c\n\x05\x04\x02\x02\x03\x06\x12\x03(\x11\x1d\n\x0c\n\x05\x04\x02\x02\
    \x03\x01\x12\x03(\x1e#\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03(&'\n\x8a\
    \x03\n\x02\x04\x03\x12\x044\0:\x012\xfd\x02\x20Using\x20an\x20ID\x20does\
    n't\x20seem\x20to\x20be\x20worth\x20it\x20compared\x20to\x20using\x20a\
    \x20hash.\n\x20While\x20this\x20may\x20not\x20be\x20strictly\x20necessar\
    y\x20as\x20a\x20messageID\x20and\x20a\x20messageHash\n\x20are\x20both\
    \x20strings,\x20it\x20would\x20be\x20useful\x20to\x20differentiate\x20be\
    tween\x20them\x20in\x20the\n\x20protobuf\x20file,\x20e.g.\x20due\x20to\
    \x20the\x20accessors\x20and\x20for\x20clarity.\n\x20enum\x20MessageRep\
    \x20{\n\x20\tID\x20=\x200\x20[(type)\x20=\x20\"ID\",\x20(code)\x20=\x20'\
    I'];\n\x20\tHASH\x20=\x201\x20[(type)\x20=\x20\"HSH\",\x20(code)\x20=\
    \x20'H'];\n\x20}\n\n\n\n\x03\x04\x03\x01\x12\x034\x08\x14\n\x0b\n\x04\
    \x04\x03\x02\0\x12\x035\x08'\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x035\x08\
    \x10\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x035\x11\x17\n\x0c\n\x05\x04\x03\
    \x02\0\x01\x12\x035\x18\"\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x035%&\n\xda\
    \x01\n\x04\x04\x03\x02\x01\x12\x039\x08+\x1a\xcc\x01\x20We\x20could\x20h\
    ave\x20a\x20repeated\x20string\x20messageIDs\x20field\x20and\x20repeated\
    \x20string\n\x20messageHash\x20field\x20here,\x20which\x20would\x20be\
    \x20better\x20for\x20backwards\n\x20compatibility,\x20although\x20hiding\
    \x20both\x20behind\x20one\x20type\x20has\x20its\x20advantages.\n\n\x0c\n\
    \x05\x04\x03\x02\x01\x04\x12\x039\x08\x10\n\x0c\n\x05\x04\x03\x02\x01\
    \x05\x12\x039\x11\x17\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x039\x18&\n\
    \x0c\n\x05\x04\x03\x02\x01\x03\x12\x039)*\n\n\n\x02\x04\x04\x12\x04<\0>\
    \x01\n\n\n\x03\x04\x04\x01\x12\x03<\x08\x14\n\x0b\n\x04\x04\x04\x02\0\
    \x12\x03=\x08+\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x03=\x08\x10\n\x0c\n\
    \x05\x04\x04\x02\0\x05\x12\x03=\x11\x17\n\x0c\n\x05\x04\x04\x02\0\x01\
    \x12\x03=\x18&\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03=)*\n\n\n\x02\x04\
    \x05\x12\x04@\0B\x01\n\n\n\x03\x04\x05\x01\x12\x03@\x08\x14\n\x0b\n\x04\
    \x04\x05\x02\0\x12\x03A\x08'\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03A\x08\
    \x10\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03A\x11\x17\n\x0c\n\x05\x04\x05\
    \x02\0\x01\x12\x03A\x18\"\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03A%&\n\n\n\
    \x02\x04\x06\x12\x04D\0F\x01\n\n\n\x03\x04\x06\x01\x12\x03D\x08\x14\n\
    \x0b\n\x04\x04\x06\x02\0\x12\x03E\x08'\n\x0c\n\x05\x04\x06\x02\0\x04\x12\
    \x03E\x08\x10\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03E\x11\x17\n\x0c\n\x05\
    \x04\x06\x02\0\x01\x12\x03E\x18\"\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03E\
    %&\n\n\n\x02\x04\x07\x12\x04H\0c\x01\n\n\n\x03\x04\x07\x01\x12\x03H\x08\
    \x17\nP\n\x04\x04\x07\x02\0\x12\x03I\x08!\"C\x20TODO:\x20use\n\x20option\
    al\x20AuthOpts\x20auth\x20=\x202;\n\x20optional\x20EncOpts\x20enc\x20=\
    \x203;\n\n\x0c\n\x05\x04\x07\x02\0\x04\x12\x03I\x08\x10\n\x0c\n\x05\x04\
    \x07\x02\0\x05\x12\x03I\x11\x17\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03I\
    \x18\x1c\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03I\x1f\x20\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
