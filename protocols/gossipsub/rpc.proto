// From https://github.com/libp2p/go-libp2p-pubsub/blob/master/pb/rpc.proto,
// should be the same unless that has been changed.

syntax = "proto2";

// import "google/protobuf/descriptor.proto";

// extend google.protobuf.EnumValueOptions {
// 	optional string type= 51234;
// 	optional string code= 51235;
//   }

package pubsub.pb;

message RPC {
	repeated SubOpts subscriptions = 1;
	repeated Message publish = 2;

	message SubOpts {
		optional bool subscribe = 1; // subscribe or unsubcribe
		optional string topic_hash = 2;
	}

	optional ControlMessage control = 3;
}

message Message {
	optional bytes from = 1;
	optional bytes data = 2;
	optional bytes seqno = 3;
	repeated string topic_hashes = 4;
	// TODO: use
	// optional bytes signature = 5;
	// optional bytes key = 6;
}

message ControlMessage {
	repeated ControlIHave ihave = 1;
	repeated ControlIWant iwant = 2;
	repeated ControlGraft graft = 3;
	repeated ControlPrune prune = 4;
}

// Using an ID doesn't seem to be worth it compared to using a hash.
// While this may not be strictly necessary as a messageID and a messageHash
// are both strings, it would be useful to differentiate between them in the
// protobuf file, e.g. due to the accessors and for clarity.
// enum MessageRep {
// 	ID = 0 [(type) = "ID", (code) = 'I'];
// 	HASH = 1 [(type) = "HSH", (code) = 'H'];
// }

message ControlIHave {
	optional string topic_hash = 1;
	repeated string message_hashes = 2;
}

message ControlIWant {
	repeated string message_hashes = 1;
}

message ControlGraft {
	optional string topic_hash = 1;
}

message ControlPrune {
	optional string topic_hash = 1;
}

message TopicDescriptor {
	optional string name = 1;
	// TODO: use
	// optional AuthOpts auth = 2;
	// optional EncOpts enc = 3;

	// message AuthOpts {
	// 	optional AuthMode mode = 1;
	// 	repeated bytes keys = 2; // root keys to trust

	// 	enum AuthMode {
	// 		NONE = 0; // no authentication, anyone can publish
	// 		KEY = 1; // only messages signed by keys in the topic descriptor are accepted
	// 		WOT = 2; // web of trust, certificates can allow publisher set to grow
	// 	}
	// }

	// message EncOpts {
	// 	optional EncMode mode = 1;
	// 	repeated bytes keyHashes = 2; // the hashes of the shared keys used (salted)

	// 	enum EncMode {
	// 		NONE = 0; // no encryption, anyone can read
	// 		SHAREDKEY = 1; // messages are encrypted with shared key
	// 		WOT = 2; // web of trust, certificates can allow publisher set to grow
	// 	}
	// }
}
